
too much stuff called expectation. dont forget expectations WRAP validators.

status method should be grabbing some kind of log. always prints last entry

not sure if Intervals are useful in their current form

rename country.can_add_influence? to country.can_receive_influence? or
  country.influenceable?

game state should only be mutated within a Move class?

need some kind of "modifiers" object that notes the current modifications in
place -- essentially a hash encapsulated by suitable methods for getting the
right info about what cards are in effect and what the current ops points are
after modification.

ensure all raises and fails use a custom or representative exception class

make influence helpers less magic -- dont rely on initialize, instead call them
explicitly. makes the task of mixing in multiple helpers less scary

consider execute blocks returning objects to describe each change - makes
hooking and checking for instant-win conditions after each change easier, as
well as clearer change-logging

  def modify(changers)
   changers.each do |c|
    c.change(game)
    check_defcon
    etc
   end
  end

all puts etc should go to a per-play action log that gets set up each play -
this then gets rolled into master log for posterity but allows player to see
what happened on the last turn

break out history into a class - lots of internalisation to do regarding
searching history for the most recent Thing

do not keep all of the modifiers inside the Modifiers class namespace. (screws
up inspect())

does the CardPlay validator need to do more work? The CardPlay move is looking
a bit fat

fix the terrible API around Country.accessible returning a list of country
NAMES. WAT. This stems from country.neighbors returning only a list of names.

need a variant on modifiers: a "forced modifier" that possibly executes before
every play -- useful for persistent and conditional punishments such as
quagmire

 X placing influence by event decree
 X placing influence by ops points
 X placing influence without spread/creep - needs snapshot of countries
     possibly add some kind of transaction api for adding influence
 X playing opponent card (+ deciding if event should occur pre/post-ops)
 X coups
 - space race
 - realignment
 - scoring card

 ~ hand/deck management (including discarding of event cards etc)
 - china card management - this is not in the "hand", also has flipped state
 ~ turn/round/player tracking: possibly some kind of executor inserted
   between ordered expectations? - player tracking remaining

 - explain why rejections occur - make Validators print in a readable way
     what they are expecting.

 - OMG TESTS (unit and integration)
 - look in manual for italicised examples of play for good integration tests
     i.e. Section 5.2 - examples 1-4

FIXED
=====

order sensitive should default to true.

should cardplay be a move with an empty execute method?

player needs to be an object.. so player.opponent can be a thing

influence creep is only applicable during influence being played during
operations, right? in this case Validators::Influence can be the single
point of enforcement for this... is this the only time that the 2:1 "cost of
entry" also applies?

